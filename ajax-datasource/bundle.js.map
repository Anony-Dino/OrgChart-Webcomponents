{"version":3,"sources":["webpack:///webpack/bootstrap df3995d0d51d6b6848e7?e8e5","webpack:///./demo/ajax-datasource/scripts.js","webpack:///orgchart-webcomponents.js?bafc"],"names":["document","addEventListener","Mock","mock","setup","timeout","orgchart","querySelector","appendChild"],"mappings":"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","file":"ajax-datasource/bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap df3995d0d51d6b6848e7","import OrgChart from '../js/orgchart-webcomponents.min.js';\n\ndocument.addEventListener('DOMContentLoaded', function () {\n\n  Mock.mock('/orgchart/initdata', {\n      'name': 'Lao Lao',\n      'title': 'general manager',\n      'children': [\n        { 'name': 'Bo Miao', 'title': 'department manager' },\n        { 'name': 'Su Miao', 'title': 'department manager',\n          'children': [\n            { 'name': 'Tie Hua', 'title': 'senior engineer' },\n            { 'name': 'Hei Hei', 'title': 'senior engineer',\n              'children': [\n                { 'name': 'Pang Pang', 'title': 'engineer' },\n                { 'name': 'Xiang Xiang', 'title': 'UE engineer' }\n              ]\n            }\n          ]\n        },\n        { 'name': 'Yu Jie', 'title': 'department manager' },\n        { 'name': 'Yu Li', 'title': 'department manager' },\n        { 'name': 'Hong Miao', 'title': 'department manager' },\n        { 'name': 'Yu Wei', 'title': 'department manager' },\n        { 'name': 'Chun Miao', 'title': 'department manager' },\n        { 'name': 'Yu Tie', 'title': 'department manager' }\n      ]\n    });\n  Mock.setup({ timeout: 1000 });\n\n  let orgchart = new OrgChart({\n    'data' : '/orgchart/initdata',\n    'depth': 2,\n    'nodeContent': 'title'\n  });\n\n  document.querySelector('#chart-container').appendChild(orgchart);\n\n});\n\n\n// WEBPACK FOOTER //\n// ./demo/ajax-datasource/scripts.js","export default class OrgChart extends HTMLElement {\n  constructor(options) {\n    super(); // always call super() first in the ctor.\n\n    /* Frankly, I do believe Show DOM has the narrow usage range. */\n    // Attach a shadow root to the element.\n    // let shadowRoot = this.attachShadow({mode: 'open'});\n\n    // shadowRoot.innerHTML = `\n    //   <style> </style>\n    //   <div class=\"container\"> </div>\n    // `;\n\n    Promise.prototype.finally = function (callback) {\n      let P = this.constructor;\n\n      return this.then(\n        value => P.resolve(callback()).then(() => value),\n        reason => P.resolve(callback()).then(() => { throw reason; })\n      );\n    };\n\n    let that = this,\n      defaultOptions = {\n        'nodeTitle': 'name',\n        'nodeId': 'id',\n        'toggleSiblingsResp': false,\n        'depth': 999,\n        'chartClass': '',\n        'parentNodeSymbol': 'fa-users',\n        'draggable': false,\n        'direction': 't2b',\n        'pan': false,\n        'zoom': false\n      },\n      opts = Object.assign(defaultOptions, options),\n      data = opts.data,\n      chart = document.createElement('div');\n\n    this.options = opts;\n    delete this.options.data;\n    this.dataset.options = JSON.stringify(opts);\n    this.setAttribute('class', 'orgchart' + (opts.chartClass !== '' ? ' ' + opts.chartClass : '') +\n      (opts.direction !== 't2b' ? ' ' + opts.direction : ''));\n    if (typeof data === 'object') { // local json datasource\n      this.buildHierarchy(this, opts.ajaxURL ? data : this._attachRel(data, '00'), 0);\n    } else if (typeof data === 'string' && data.startsWith('#')) { // ul datasource\n      this.buildHierarchy(this, this._buildJsonDS(document.querySelector(data).children[0]), 0);\n    } else { // ajax datasource\n      let spinner = document.createElement('i');\n\n      spinner.setAttribute('class', 'fa fa-circle-o-notch fa-spin spinner');\n      this.appendChild(spinner);\n      this._getJSON(data)\n      .then(function (resp) {\n        that.buildHierarchy(that, opts.ajaxURL ? resp : that._attachRel(resp, '00'), 0);\n      })\n      .catch(function (err) {\n        console.error('failed to fetch datasource for orgchart', err);\n      })\n      .finally(function () {\n        let spinner = that.querySelector('.spinner');\n\n        spinner.parentNode.removeChild(spinner);\n      });\n    }\n    this.addEventListener('click', this._clickChart.bind(this));\n\n\n    if (opts.pan && opts.chartContainer) {\n      let chartContainer = document.querySelector(opts.chartContainer);\n\n      chartContainer.style.overflow = 'hidden';\n      this.addEventListener('mousedown', this._onPanStart.bind(this));\n      this.addEventListener('touchstart', this._onPanStart.bind(this));\n      document.body.addEventListener('mouseup', this._onPanEnd.bind(this));\n      document.body.addEventListener('touchend', this._onPanEnd.bind(this));\n    }\n\n    if (opts.zoom && opts.chartContainer) {\n      let chartContainer = document.querySelector(opts.chartContainer);\n\n      chartContainer.addEventListener('wheel', this._onWheeling.bind(this));\n      chartContainer.addEventListener('touchstart', this._onTouchStart.bind(this));\n      document.body.addEventListener('touchmove', this._onTouchMove.bind(this));\n      document.body.addEventListener('touchend', this._onTouchEnd.bind(this));\n    }\n  }\n  connectedCallback() {\n\n  }\n  disconnectedCallback() {\n\n  }\n  attributeChangedCallback(attrName, oldVal, newVal) {\n\n  }\n\n  _closest(el, fn) {\n    return el && ((fn(el) && el !== this) ? el : this._closest(el.parentNode, fn));\n  }\n  _siblings(el, expr) {\n    return Array.from(el.parentNode.children).filter((child) => {\n      if (child !== el) {\n        if (expr) {\n          return el.matches(expr);\n        }\n        return true;\n      }\n      return false;\n    });\n  }\n  _prevAll(el, expr) {\n    let sibs = [],\n      prevSib = el.previousElementSibling;\n\n    while (prevSib) {\n      if (!expr || prevSib.matches(expr)) {\n        sibs.push(prevSib);\n      }\n      prevSib = prevSib.previousElementSibling;\n    }\n    return sibs;\n  }\n  _nextAll(el, expr) {\n    let sibs = [];\n    let nextSib = el.nextElementSibling;\n\n    while (nextSib) {\n      if (!expr || nextSib.matches(expr)) {\n        sibs.push(nextSib);\n      }\n      nextSib = nextSib.nextElementSibling;\n    }\n    return sibs;\n  }\n  _isVisible(el) {\n    return el.offsetParent !== null;\n  }\n  _addClass(elements, classNames) {\n    elements.forEach((el) => {\n      if (classNames.indexOf(' ') > 0) {\n        classNames.split(' ').forEach((className) => el.classList.add(className));\n      } else {\n        el.classList.add(classNames);\n      }\n    });\n  }\n  _removeClass(elements, classNames) {\n    elements.forEach((el) => {\n      if (classNames.indexOf(' ') > 0) {\n        classNames.split(' ').forEach((className) => el.classList.remove(className));\n      } else {\n        el.classList.remove(classNames);\n      }\n    });\n  }\n  _css(elements, prop, val) {\n    elements.forEach((el) => {\n      el.style[prop] = val;\n    });\n  }\n  _removeAttr(elements, attr) {\n    elements.forEach((el) => {\n      el.removeAttribute(attr);\n    });\n  }\n  _one(el, type, listener, self) {\n    let one = function (event) {\n      try {\n        listener.call(self, event);\n      } finally {\n        el.removeEventListener(type, one);\n      }\n    };\n\n    el.addEventListener(type, one);\n  }\n  _getDescElements(ancestors, selector) {\n    let results = [];\n\n    ancestors.forEach((el) => results.push(...el.querySelectorAll(selector)));\n    return results;\n  }\n  _getJSON(url) {\n    return new Promise(function (resolve, reject) {\n      let xhr = new XMLHttpRequest();\n\n      function handler() {\n        if (this.readyState !== 4) {\n          return;\n        }\n        if (this.status === 200) {\n          resolve(JSON.parse(this.response));\n        } else {\n          reject(new Error(this.statusText));\n        }\n      }\n      xhr.open('GET', url);\n      xhr.onreadystatechange = handler;\n      xhr.responseType = 'json';\n      // xhr.setRequestHeader('Accept', 'application/json');\n      xhr.setRequestHeader('Content-Type', 'application/json');\n      xhr.send();\n    });\n  }\n  _buildJsonDS(li) {\n    let subObj = {\n      'name': li.firstChild.textContent.trim(),\n      'relationship': (li.parentNode.parentNode.nodeName === 'LI' ? '1' : '0') +\n        (li.parentNode.children.length > 1 ? 1 : 0) + (li.children.length ? 1 : 0)\n    };\n\n    if (li.id) {\n      subObj.id = li.id;\n    }\n    if (li.querySelector('ul')) {\n      Array.from(li.querySelector('ul').children).forEach((el) => {\n        if (!subObj.children) { subObj.children = []; }\n        subObj.children.push(this._buildJsonDS(el));\n      });\n    }\n    return subObj;\n  }\n  _attachRel(data, flags) {\n    data.relationship = flags + (data.children && data.children.length > 0 ? 1 : 0);\n    if (data.children) {\n      for (let item of data.children) {\n        this._attachRel(item, '1' + (data.children.length > 1 ? 1 : 0));\n      }\n    }\n    return data;\n  }\n  _repaint(node) {\n    if (node) {\n      node.style.offsetWidth = node.offsetWidth;\n    }\n  }\n  // whether the cursor is hovering over the node\n  _isInAction(node) {\n    return node.querySelector(':scope > .edge').className.indexOf('fa-') > -1;\n  }\n  // detect the exist/display state of related node\n  _getNodeState(node, relation) {\n    let criteria,\n      state = { 'exist': false, 'visible': false };\n\n    if (relation === 'parent') {\n      criteria = this._closest(node, (el) => el.classList && el.classList.contains('nodes'));\n      if (criteria) {\n        state.exist = true;\n      }\n      if (state.exist && this._isVisible(criteria.parentNode.children[0])) {\n        state.visible = true;\n      }\n    } else if (relation === 'children') {\n      criteria = this._closest(node, (el) => el.nodeName === 'TR').nextElementSibling;\n      if (criteria) {\n        state.exist = true;\n      }\n      if (state.exist && this._isVisible(criteria)) {\n        state.visible = true;\n      }\n    } else if (relation === 'siblings') {\n      criteria = this._siblings(this._closest(node, (el) => el.nodeName === 'TABLE').parentNode);\n      if (criteria.length) {\n        state.exist = true;\n      }\n      if (state.exist && criteria.some((el) => this._isVisible(el))) {\n        state.visible = true;\n      }\n    }\n\n    return state;\n  }\n  // find the related nodes\n  getRelatedNodes(node, relation) {\n    if (relation === 'parent') {\n      return this._closest(node, (el) => el.classList.contains('nodes'))\n        .parentNode.children[0].querySelector('.node');\n    } else if (relation === 'children') {\n      return Array.from(this._closest(node, (el) => el.nodeName === 'TABLE').lastChild.children)\n        .map((el) => el.querySelector('.node'));\n    } else if (relation === 'siblings') {\n      return this._siblings(this._closest(node, (el) => el.nodeName === 'TABLE').parentNode)\n        .map((el) => el.querySelector('.node'));\n    }\n    return [];\n  }\n  _switchHorizontalArrow(node) {\n    let opts = this.options,\n      leftEdge = node.querySelector('.leftEdge'),\n      rightEdge = node.querySelector('.rightEdge'),\n      temp = this._closest(node, (el) => el.nodeName === 'TABLE').parentNode;\n\n    if (opts.toggleSiblingsResp && (typeof opts.ajaxURL === 'undefined' ||\n      this._closest(node, (el) => el.classList.contains('.nodes')).dataset.siblingsLoaded)) {\n      let prevSib = temp.previousElementSibling,\n        nextSib = temp.nextElementSibling;\n\n      if (prevSib) {\n        if (prevSib.classList.contains('hidden')) {\n          leftEdge.classList.add('fa-chevron-left');\n          leftEdge.classList.remove('fa-chevron-right');\n        } else {\n          leftEdge.classList.add('fa-chevron-right');\n          leftEdge.classList.remove('fa-chevron-left');\n        }\n      }\n      if (nextSib) {\n        if (nextSib.classList.contains('hidden')) {\n          rightEdge.classList.add('fa-chevron-right');\n          rightEdge.classList.remove('fa-chevron-left');\n        } else {\n          rightEdge.classList.add('fa-chevron-left');\n          rightEdge.classList.remove('fa-chevron-right');\n        }\n      }\n    } else {\n      let sibs = this._siblings(temp),\n        sibsVisible = sibs.length ? !sibs.some((el) => el.classList.contains('hidden')) : false;\n\n      leftEdge.classList.toggle('fa-chevron-right', sibsVisible);\n      leftEdge.classList.toggle('fa-chevron-left', !sibsVisible);\n      rightEdge.classList.toggle('fa-chevron-left', sibsVisible);\n      rightEdge.classList.toggle('fa-chevron-right', !sibsVisible);\n    }\n  }\n  _hoverNode(event) {\n    let node = event.target,\n      flag = false,\n      topEdge = node.querySelector(':scope > .topEdge'),\n      bottomEdge = node.querySelector(':scope > .bottomEdge'),\n      leftEdge = node.querySelector(':scope > .leftEdge');\n\n    if (event.type === 'mouseenter') {\n      if (topEdge) {\n        flag = this._getNodeState(node, 'parent').visible;\n        topEdge.classList.toggle('fa-chevron-up', !flag);\n        topEdge.classList.toggle('fa-chevron-down', flag);\n      }\n      if (bottomEdge) {\n        flag = this._getNodeState(node, 'children').visible;\n        bottomEdge.classList.toggle('fa-chevron-down', !flag);\n        bottomEdge.classList.toggle('fa-chevron-up', flag);\n      }\n      if (leftEdge) {\n        this._switchHorizontalArrow(node);\n      }\n    } else {\n      Array.from(node.querySelectorAll(':scope > .edge')).forEach((el) => {\n        el.classList.remove('fa-chevron-up', 'fa-chevron-down', 'fa-chevron-right', 'fa-chevron-left');\n      });\n    }\n  }\n  // define node click event handler\n  _clickNode(event) {\n    let clickedNode = event.currentTarget,\n      focusedNode = this.querySelector('.focused');\n\n    if (focusedNode) {\n      focusedNode.classList.remove('focused');\n    }\n    clickedNode.classList.add('focused');\n  }\n  // build the parent node of specific node\n  _buildParentNode(currentRoot, nodeData, callback) {\n    let that = this,\n      table = document.createElement('table');\n\n    nodeData.relationship = '001';\n    this._createNode(nodeData, 0)\n      .then(function (nodeDiv) {\n        nodeDiv.classList.remove('slide-up');\n        nodeDiv.classList.add('slide-down');\n        let parentTr = document.createElement('tr'),\n          superiorLine = document.createElement('tr'),\n          inferiorLine = document.createElement('tr'),\n          childrenTr = document.createElement('tr');\n\n        parentTr.setAttribute('class', 'hidden');\n        parentTr.innerHTML = `<td colspan=\"2\"></td>`;\n        table.appendChild(parentTr);\n        superiorLine.setAttribute('class', 'lines hidden');\n        superiorLine.innerHTML = `<td colspan=\"2\"><div class=\"downLine\"></div></td>`;\n        table.appendChild(superiorLine);\n        inferiorLine.setAttribute('class', 'lines hidden');\n        inferiorLine.innerHTML = `<td class=\"rightLine\">&nbsp;</td><td class=\"leftLine\">&nbsp;</td>`;\n        table.appendChild(inferiorLine);\n        childrenTr.setAttribute('class', 'nodes');\n        childrenTr.innerHTML = `<td colspan=\"2\"></td>`;\n        table.appendChild(childrenTr);\n        table.querySelector('td').appendChild(nodeDiv);\n        that.insertBefore(table, that.children[0]);\n        table.children[3].children[0].appendChild(that.lastChild);\n        callback();\n      })\n      .catch(function (err) {\n        console.error('Failed to create parent node', err);\n      });\n  }\n  _switchVerticalArrow(arrow) {\n    arrow.classList.toggle('fa-chevron-up');\n    arrow.classList.toggle('fa-chevron-down');\n  }\n  // show the parent node of the specified node\n  showParent(node) {\n    // just show only one superior level\n    let temp = this._prevAll(this._closest(node, (el) => el.classList.contains('nodes')));\n\n    this._removeClass(temp, 'hidden');\n    // just show only one line\n    this._addClass(Array(temp[0].children).slice(1, -1), 'hidden');\n    // show parent node with animation\n    let parent = temp[2].querySelector('.node');\n\n    this._one(parent, 'transitionend', function () {\n      parent.classList.remove('slide');\n      if (this._isInAction(node)) {\n        this._switchVerticalArrow(node.querySelector(':scope > .topEdge'));\n      }\n    }, this);\n    this._repaint(parent);\n    parent.classList.add('slide');\n    parent.classList.remove('slide-down');\n  }\n  // show the sibling nodes of the specified node\n  showSiblings(node, direction) {\n    // firstly, show the sibling td tags\n    let siblings = [],\n      temp = this._closest(node, (el) => el.nodeName === 'TABLE').parentNode;\n\n    if (direction) {\n      siblings = direction === 'left' ? this._prevAll(temp) : this._nextAll(temp);\n    } else {\n      siblings = this._siblings(temp);\n    }\n    this._removeClass(siblings, 'hidden');\n    // secondly, show the lines\n    let upperLevel = this._prevAll(this._closest(node, (el) => el.classList.contains('nodes')));\n\n    temp = Array.from(upperLevel[0].querySelectorAll(':scope > .hidden'));\n    if (direction) {\n      this._removeClass(temp.slice(0, siblings.length * 2), 'hidden');\n    } else {\n      this._removeClass(temp, 'hidden');\n    }\n    // thirdly, do some cleaning stuff\n    if (!this._getNodeState(node, 'parent').visible) {\n      this._removeClass(upperLevel, 'hidden');\n      let parent = upperLevel[2].querySelector('.node');\n\n      this._one(parent, 'transitionend', function (event) {\n        event.target.classList.remove('slide');\n      }, this);\n      this._repaint(parent);\n      parent.classList.add('slide');\n      parent.classList.remove('slide-down');\n    }\n    // lastly, show the sibling nodes with animation\n    siblings.forEach((sib) => {\n      Array.from(sib.querySelectorAll('.node')).forEach((node) => {\n        if (this._isVisible(node)) {\n          node.classList.add('slide');\n          node.classList.remove('slide-left', 'slide-right');\n        }\n      });\n    });\n    this._one(siblings[0].querySelector('.slide'), 'transitionend', function () {\n      siblings.forEach((sib) => {\n        this._removeClass(Array.from(sib.querySelectorAll('.slide')), 'slide');\n      });\n      if (this._isInAction(node)) {\n        this._switchHorizontalArrow(node);\n        node.querySelector('.topEdge').classList.remove('fa-chevron-up');\n        node.querySelector('.topEdge').classList.add('fa-chevron-down');\n      }\n    }, this);\n  }\n  // hide the sibling nodes of the specified node\n  hideSiblings(node, direction) {\n    let nodeContainer = this._closest(node, (el) => el.nodeName === 'TABLE').parentNode,\n      siblings = this._siblings(nodeContainer);\n\n    siblings.forEach((sib) => {\n      if (sib.querySelector('.spinner')) {\n        this.dataset.inAjax = false;\n      }\n    });\n\n    if (!direction || (direction && direction === 'left')) {\n      let preSibs = this._prevAll(nodeContainer);\n\n      preSibs.forEach((sib) => {\n        Array.from(sib.querySelectorAll('.node')).forEach((node) => {\n          if (this._isVisible(node)) {\n            node.classList.add('slide', 'slide-right');\n          }\n        });\n      });\n    }\n    if (!direction || (direction && direction !== 'left')) {\n      let nextSibs = this._nextAll(nodeContainer);\n\n      nextSibs.forEach((sib) => {\n        Array.from(sib.querySelectorAll('.node')).forEach((node) => {\n          if (this._isVisible(node)) {\n            node.classList.add('slide', 'slide-left');\n          }\n        });\n      });\n    }\n\n    let animatedNodes = [];\n\n    this._siblings(nodeContainer).forEach((sib) => {\n      Array.prototype.push.apply(animatedNodes, Array.from(sib.querySelectorAll('.slide')));\n    });\n    let lines = [];\n\n    for (let node of animatedNodes) {\n      let temp = this._closest(node, function (el) {\n        return el.classList.contains('nodes');\n      }).previousElementSibling;\n\n      lines.push(temp);\n      lines.push(temp.previousElementSibling);\n    }\n    lines = [...new Set(lines)];\n    lines.forEach(function (line) {\n      line.style.visibility = 'hidden';\n    });\n\n    this._one(animatedNodes[0], 'transitionend', function (event) {\n      lines.forEach(function (line) {\n        line.removeAttribute('style');\n      });\n      let sibs = [];\n\n      if (direction) {\n        if (direction === 'left') {\n          sibs = this._prevAll(nodeContainer, ':not(.hidden)');\n        } else {\n          sibs = this._nextAll(nodeContainer, ':not(.hidden)');\n        }\n      } else {\n        sibs = this._siblings(nodeContainer);\n      }\n      let temp = Array.from(this._closest(nodeContainer, function (el) {\n        return el.classList.contains('nodes');\n      }).previousElementSibling.querySelectorAll(':scope > :not(.hidden)'));\n\n      let someLines = temp.slice(1, direction ? sibs.length * 2 + 1 : -1);\n\n      this._addClass(someLines, 'hidden');\n      this._removeClass(animatedNodes, 'slide');\n      sibs.forEach((sib) => {\n        Array.from(sib.querySelectorAll('.node')).slice(1).forEach((node) => {\n          if (this._isVisible(node)) {\n            node.classList.remove('slide-left', 'slide-right');\n            node.classList.add('slide-up');\n          }\n        });\n      });\n      sibs.forEach((sib) => {\n        this._addClass(Array.from(sib.querySelectorAll('.lines')), 'hidden');\n        this._addClass(Array.from(sib.querySelectorAll('.nodes')), 'hidden');\n        this._addClass(Array.from(sib.querySelectorAll('.verticalNodes')), 'hidden');\n      });\n      this._addClass(sibs, 'hidden');\n\n      if (this._isInAction(node)) {\n        this._switchHorizontalArrow(node);\n      }\n    }, this);\n  }\n  // recursively hide the ancestor node and sibling nodes of the specified node\n  hideParent(node) {\n    let temp = Array.from(this._closest(node, function (el) {\n      return el.classList.contains('nodes');\n    }).parentNode.children).slice(0, 3);\n\n    if (temp[0].querySelector('.spinner')) {\n      this.dataset.inAjax = false;\n    }\n    // hide the sibling nodes\n    if (this._getNodeState(node, 'siblings').visible) {\n      this.hideSiblings(node);\n    }\n    // hide the lines\n    let lines = temp.slice(1);\n\n    this._css(lines, 'visibility', 'hidden');\n    // hide the superior nodes with transition\n    let parent = temp[0].querySelector('.node'),\n      grandfatherVisible = this._getNodeState(parent, 'parent').visible;\n\n    if (parent && this._isVisible(parent)) {\n      parent.classList.add('slide', 'slide-down');\n      this._one(parent, 'transitionend', function () {\n        parent.classList.remove('slide');\n        this._removeAttr(lines, 'style');\n        this._addClass(temp, 'hidden');\n      }, this);\n    }\n    // if the current node has the parent node, hide it recursively\n    if (parent && grandfatherVisible) {\n      this.hideParent(parent);\n    }\n  }\n  // exposed method\n  addParent(currentRoot, data) {\n    let that = this;\n\n    this._buildParentNode(currentRoot, data, function () {\n      if (!currentRoot.querySelector(':scope > .topEdge')) {\n        let topEdge = document.createElement('i');\n\n        topEdge.setAttribute('class', 'edge verticalEdge topEdge fa');\n        currentRoot.appendChild(topEdge);\n      }\n      that.showParent(currentRoot);\n    });\n  }\n  // start up loading status for requesting new nodes\n  _startLoading(arrow, node) {\n    let opts = this.options;\n\n    if (typeof this.dataset.inAjax !== 'undefined' && this.dataset.inAjax === 'true') {\n      return false;\n    }\n\n    arrow.classList.add('hidden');\n    let spinner = document.createElement('i');\n\n    spinner.setAttribute('class', 'fa fa-circle-o-notch fa-spin spinner');\n    node.appendChild(spinner);\n    this._addClass(Array.from(node.querySelectorAll(':scope > *:not(.spinner)')), 'hazy');\n    this.dataset.inAjax = true;\n\n    return true;\n  }\n  // terminate loading status for requesting new nodes\n  _endLoading(arrow, node) {\n    let opts = this.options;\n\n    arrow.classList.remove('hidden');\n    node.querySelector(':scope > .spinner').remove();\n    this._removeClass(Array.from(node.querySelectorAll(':scope > .hazy')), 'hazy');\n    this.dataset.inAjax = false;\n  }\n  // define click event handler for the top edge\n  _clickTopEdge(event) {\n    event.stopPropagation();\n    let that = this,\n      topEdge = event.target,\n      node = topEdge.parentNode,\n      parentState = this._getNodeState(node, 'parent'),\n      opts = this.options;\n\n    if (parentState.exist) {\n      let temp = this._closest(node, function (el) {\n        return el.classList.contains('nodes');\n      });\n      let parent = temp.parentNode.firstChild.querySelector('.node');\n\n      if (parent.classList.contains('slide')) { return; }\n      // hide the ancestor nodes and sibling nodes of the specified node\n      if (parentState.visible) {\n        this.hideParent(node);\n        this._one(parent, 'transitionend', function () {\n          if (this._isInAction(node)) {\n            this._switchVerticalArrow(topEdge);\n            this._switchHorizontalArrow(node);\n          }\n        }, this);\n      } else { // show the ancestors and siblings\n        this.showParent(node);\n      }\n    } else {\n      // load the new parent node of the specified node by ajax request\n      let nodeId = topEdge.parentNode.id;\n\n      // start up loading status\n      if (this._startLoading(topEdge, node)) {\n        // load new nodes\n        this._getJSON(typeof opts.ajaxURL.parent === 'function' ?\n          opts.ajaxURL.parent(node.dataset.source) : opts.ajaxURL.parent + nodeId)\n        .then(function (resp) {\n          if (that.dataset.inAjax === 'true') {\n            if (Object.keys(resp).length) {\n              that.addParent(node, resp);\n            }\n          }\n        })\n        .catch(function (err) {\n          console.error('Failed to get parent node data.', err);\n        })\n        .finally(function () {\n          that._endLoading(topEdge, node);\n        });\n      }\n    }\n  }\n  // recursively hide the descendant nodes of the specified node\n  hideChildren(node) {\n    let that = this,\n      temp = this._nextAll(node.parentNode.parentNode),\n      lastItem = temp[temp.length - 1],\n      lines = [];\n\n    if (lastItem.querySelector('.spinner')) {\n      this.dataset.inAjax = false;\n    }\n    let descendants = Array.from(lastItem.querySelectorAll('.node')).filter((el) => that._isVisible(el)),\n      isVerticalDesc = lastItem.classList.contains('verticalNodes');\n\n    if (!isVerticalDesc) {\n      descendants.forEach((desc) => {\n        Array.prototype.push.apply(lines,\n          that._prevAll(that._closest(desc, (el) => el.classList.contains('nodes')), '.lines'));\n      });\n      lines = [...new Set(lines)];\n      this._css(lines, 'visibility', 'hidden');\n    }\n    this._one(descendants[0], 'transitionend', function (event) {\n      this._removeClass(descendants, 'slide');\n      if (isVerticalDesc) {\n        that._addClass(temp, 'hidden');\n      } else {\n        lines.forEach((el) => {\n          el.removeAttribute('style');\n          el.classList.add('hidden');\n          el.parentNode.lastChild.classList.add('hidden');\n        });\n        this._addClass(Array.from(lastItem.querySelectorAll('.verticalNodes')), 'hidden');\n      }\n      if (this._isInAction(node)) {\n        this._switchVerticalArrow(node.querySelector('.bottomEdge'));\n      }\n    }, this);\n    this._addClass(descendants, 'slide slide-up');\n  }\n  // show the children nodes of the specified node\n  showChildren(node) {\n    let that = this,\n      temp = this._nextAll(node.parentNode.parentNode),\n      descendants = [];\n\n    this._removeClass(temp, 'hidden');\n    if (temp.some((el) => el.classList.contains('verticalNodes'))) {\n      temp.forEach((el) => {\n        Array.prototype.push.apply(descendants, Array.from(el.querySelectorAll('.node')).filter((el) => {\n          return that._isVisible(el);\n        }));\n      });\n    } else {\n      Array.from(temp[2].children).forEach((el) => {\n        Array.prototype.push.apply(descendants,\n          Array.from(el.querySelector('tr').querySelectorAll('.node')).filter((el) => {\n            return that._isVisible(el);\n          }));\n      });\n    }\n    // the two following statements are used to enforce browser to repaint\n    this._repaint(descendants[0]);\n    this._one(descendants[0], 'transitionend', (event) => {\n      this._removeClass(descendants, 'slide');\n      if (this._isInAction(node)) {\n        this._switchVerticalArrow(node.querySelector('.bottomEdge'));\n      }\n    }, this);\n    this._addClass(descendants, 'slide');\n    this._removeClass(descendants, 'slide-up');\n  }\n  // build the child nodes of specific node\n  _buildChildNode(appendTo, nodeData, callback) {\n    let data = nodeData.children || nodeData.siblings;\n\n    appendTo.querySelector('td').setAttribute('colSpan', data.length * 2);\n    this.buildHierarchy(appendTo, { 'children': data }, 0, callback);\n  }\n  // exposed method\n  addChildren(node, data) {\n    let that = this,\n      opts = this.options,\n      count = 0;\n\n    this.dataset.inEdit = 'addChildren';\n    this._buildChildNode.call(this, this._closest(node, (el) => el.nodeName === 'TABLE'), data, function () {\n      if (++count === data.children.length) {\n        if (!node.querySelector('.bottomEdge')) {\n          let bottomEdge = document.createElement('i');\n\n          bottomEdge.setAttribute('class', 'edge verticalEdge bottomEdge fa');\n          node.appendChild(bottomEdge);\n        }\n        if (!node.querySelector('.symbol')) {\n          let symbol = document.createElement('i');\n\n          symbol.setAttribute('class', 'fa ' + opts.parentNodeSymbol + ' symbol');\n          node.querySelector(':scope > .title').appendChild(symbol);\n        }\n        that.showChildren(node);\n        that.dataset.inEdit = '';\n      }\n    });\n  }\n  // bind click event handler for the bottom edge\n  _clickBottomEdge(event) {\n    event.stopPropagation();\n    let that = this,\n      opts = this.options,\n      bottomEdge = event.target,\n      node = bottomEdge.parentNode,\n      childrenState = this._getNodeState(node, 'children');\n\n    if (childrenState.exist) {\n      let temp = this._closest(node, function (el) {\n        return el.nodeName === 'TR';\n      }).parentNode.lastChild;\n\n      if (Array.from(temp.querySelectorAll('.node')).some((node) => {\n        return this._isVisible(node) && node.classList.contains('slide');\n      })) { return; }\n      // hide the descendant nodes of the specified node\n      if (childrenState.visible) {\n        this.hideChildren(node);\n      } else { // show the descendants\n        this.showChildren(node);\n      }\n    } else { // load the new children nodes of the specified node by ajax request\n      let nodeId = bottomEdge.parentNode.id;\n\n      if (this._startLoading(bottomEdge, node)) {\n        this._getJSON(typeof opts.ajaxURL.children === 'function' ?\n          opts.ajaxURL.children(node.dataset.source) : opts.ajaxURL.children + nodeId)\n        .then(function (resp) {\n          if (that.dataset.inAjax === 'true') {\n            if (resp.children.length) {\n              that.addChildren(node, resp);\n            }\n          }\n        })\n        .catch(function (err) {\n          console.error('Failed to get children nodes data', err);\n        })\n        .finally(function () {\n          that._endLoading(bottomEdge, node);\n        });\n      }\n    }\n  }\n  // subsequent processing of build sibling nodes\n  _complementLine(oneSibling, siblingCount, existingSibligCount) {\n    let temp = oneSibling.parentNode.parentNode.children;\n\n    temp[0].children[0].setAttribute('colspan', siblingCount * 2);\n    temp[1].children[0].setAttribute('colspan', siblingCount * 2);\n    for (let i = 0; i < existingSibligCount; i++) {\n      let rightLine = document.createElement('td'),\n        leftLine = document.createElement('td');\n\n      rightLine.setAttribute('class', 'rightLine topLine');\n      rightLine.innerHTML = '&nbsp;';\n      temp[2].insertBefore(rightLine, temp[2].children[1]);\n      leftLine.setAttribute('class', 'leftLine topLine');\n      leftLine.innerHTML = '&nbsp;';\n      temp[2].insertBefore(leftLine, temp[2].children[1]);\n    }\n  }\n  // build the sibling nodes of specific node\n  _buildSiblingNode(nodeChart, nodeData, callback) {\n    let that = this,\n      newSiblingCount = nodeData.siblings ? nodeData.siblings.length : nodeData.children.length,\n      existingSibligCount = nodeChart.parentNode.nodeName === 'TD' ? this._closest(nodeChart, (el) => {\n        return el.nodeName === 'TR';\n      }).children.length : 1,\n      siblingCount = existingSibligCount + newSiblingCount,\n      insertPostion = (siblingCount > 1) ? Math.floor(siblingCount / 2 - 1) : 0;\n\n    // just build the sibling nodes for the specific node\n    if (nodeChart.parentNode.nodeName === 'TD') {\n      let temp = this._prevAll(nodeChart.parentNode.parentNode);\n\n      temp[0].remove();\n      temp[1].remove();\n      let childCount = 0;\n\n      that._buildChildNode.call(that, that._closest(nodeChart.parentNode, (el) => el.nodeName === 'TABLE'),\n        nodeData, () => {\n          if (++childCount === newSiblingCount) {\n            let siblingTds = Array.from(that._closest(nodeChart.parentNode, (el) => el.nodeName === 'TABLE')\n              .lastChild.children);\n\n            if (existingSibligCount > 1) {\n              let temp = nodeChart.parentNode.parentNode;\n\n              Array.from(temp.children).forEach((el) => {\n                siblingTds[0].parentNode.insertBefore(el, siblingTds[0]);\n              });\n              temp.remove();\n              that._complementLine(siblingTds[0], siblingCount, existingSibligCount);\n              that._addClass(siblingTds, 'hidden');\n              siblingTds.forEach((el) => {\n                that._addClass(el.querySelectorAll('.node'), 'slide-left');\n              });\n            } else {\n              let temp = nodeChart.parentNode.parentNode;\n\n              siblingTds[insertPostion].parentNode.insertBefore(nodeChart.parentNode, siblingTds[insertPostion + 1]);\n              temp.remove();\n              that._complementLine(siblingTds[insertPostion], siblingCount, 1);\n              that._addClass(siblingTds, 'hidden');\n              that._addClass(that._getDescElements(siblingTds.slice(0, insertPostion + 1), '.node'), 'slide-right');\n              that._addClass(that._getDescElements(siblingTds.slice(insertPostion + 1), '.node'), 'slide-left');\n            }\n            callback();\n          }\n        });\n    } else { // build the sibling nodes and parent node for the specific ndoe\n      let nodeCount = 0;\n\n      that.buildHierarchy.call(that, that, nodeData, 0, () => {\n        if (++nodeCount === siblingCount) {\n          let temp = nodeChart.nextElementSibling.children[3]\n            .children[insertPostion],\n            td = document.createElement('td');\n\n          td.setAttribute('colspan', 2);\n          td.appendChild(nodeChart);\n          temp.parentNode.insertBefore(td, temp.nextElementSibling);\n          that._complementLine(temp, siblingCount, 1);\n\n          let temp2 = that._closest(nodeChart, (el) => el.classList && el.classList.contains('nodes'))\n            .parentNode.children[0];\n\n          temp2.classList.add('hidden');\n          that._addClass(Array.from(temp2.querySelectorAll('.node')), 'slide-down');\n\n          let temp3 = this._siblings(nodeChart.parentNode);\n\n          that._addClass(temp3, 'hidden');\n          that._addClass(that._getDescElements(temp3.slice(0, insertPostion), '.node'), 'slide-right');\n          that._addClass(that._getDescElements(temp3.slice(insertPostion), '.node'), 'slide-left');\n          callback();\n        }\n      });\n    }\n  }\n  addSiblings(node, data) {\n    let that = this;\n\n    this.dataset.inEdit = 'addSiblings';\n    this._buildSiblingNode.call(this, this._closest(node, (el) => el.nodeName === 'TABLE'), data, () => {\n      that._closest(node, (el) => el.classList && el.classList.contains('nodes'))\n        .dataset.siblingsLoaded = true;\n      if (!node.querySelector('.leftEdge')) {\n        let rightEdge = document.createElement('i'),\n          leftEdge = document.createElement('i');\n\n        rightEdge.setAttribute('class', 'edge horizontalEdge rightEdge fa');\n        node.appendChild(rightEdge);\n        leftEdge.setAttribute('class', 'edge horizontalEdge leftEdge fa');\n        node.appendChild(leftEdge);\n      }\n      that.showSiblings(node);\n      that.dataset.inEdit = '';\n    });\n  }\n  removeNodes(node) {\n    let parent = this._closest(node, el => el.nodeName === 'TABLE').parentNode,\n      sibs = this._siblings(parent.parentNode);\n\n    if (parent.nodeName === 'TD') {\n      if (this._getNodeState(node, 'siblings').exist) {\n        sibs[2].querySelector('.topLine').nextElementSibling.remove();\n        sibs[2].querySelector('.topLine').remove();\n        sibs[0].children[0].setAttribute('colspan', sibs[2].children.length);\n        sibs[1].children[0].setAttribute('colspan', sibs[2].children.length);\n        parent.remove();\n      } else {\n        sibs[0].children[0].removeAttribute('colspan');\n        sibs[0].querySelector('.bottomEdge').remove();\n        this._siblings(sibs[0]).forEach(el => el.remove());\n      }\n    } else {\n      Array.from(parent.parentNode.children).forEach(el => el.remove());\n    }\n  }\n  // bind click event handler for the left and right edges\n  _clickHorizontalEdge(event) {\n    event.stopPropagation();\n    let that = this,\n      opts = this.options,\n      hEdge = event.target,\n      node = hEdge.parentNode,\n      siblingsState = this._getNodeState(node, 'siblings');\n\n    if (siblingsState.exist) {\n      let temp = this._closest(node, function (el) {\n          return el.nodeName === 'TABLE';\n        }).parentNode,\n        siblings = this._siblings(temp);\n\n      if (siblings.some((el) => {\n        let node = el.querySelector('.node');\n\n        return this._isVisible(node) && node.classList.contains('slide');\n      })) { return; }\n      if (opts.toggleSiblingsResp) {\n        let prevSib = this._closest(node, (el) => el.nodeName === 'TABLE').parentNode.previousElementSibling,\n          nextSib = this._closest(node, (el) => el.nodeName === 'TABLE').parentNode.nextElementSibling;\n\n        if (hEdge.classList.contains('leftEdge')) {\n          if (prevSib.classList.contains('hidden')) {\n            this.showSiblings(node, 'left');\n          } else {\n            this.hideSiblings(node, 'left');\n          }\n        } else {\n          if (nextSib.classList.contains('hidden')) {\n            this.showSiblings(node, 'right');\n          } else {\n            this.hideSiblings(node, 'right');\n          }\n        }\n      } else {\n        if (siblingsState.visible) {\n          this.hideSiblings(node);\n        } else {\n          this.showSiblings(node);\n        }\n      }\n    } else {\n      // load the new sibling nodes of the specified node by ajax request\n      let nodeId = hEdge.parentNode.id,\n        url = (this._getNodeState(node, 'parent').exist) ?\n          (typeof opts.ajaxURL.siblings === 'function' ?\n            opts.ajaxURL.siblings(JSON.parse(node.dataset.source)) : opts.ajaxURL.siblings + nodeId) :\n          (typeof opts.ajaxURL.families === 'function' ?\n            opts.ajaxURL.families(JSON.parse(node.dataset.source)) : opts.ajaxURL.families + nodeId);\n\n      if (this._startLoading(hEdge, node)) {\n        this._getJSON(url)\n        .then(function (resp) {\n          if (that.dataset.inAjax === 'true') {\n            if (resp.siblings || resp.children) {\n              that.addSiblings(node, resp);\n            }\n          }\n        })\n        .catch(function (err) {\n          console.error('Failed to get sibling nodes data', err);\n        })\n        .finally(function () {\n          that._endLoading(hEdge, node);\n        });\n      }\n    }\n  }\n  // event handler for toggle buttons in Hybrid(horizontal + vertical) OrgChart\n  _clickToggleButton(event) {\n    let that = this,\n      toggleBtn = event.target,\n      descWrapper = toggleBtn.parentNode.nextElementSibling,\n      descendants = Array.from(descWrapper.querySelectorAll('.node')),\n      children = Array.from(descWrapper.children).map(item => item.querySelector('.node'));\n\n    if (children.some((item) => item.classList.contains('slide'))) { return; }\n    toggleBtn.classList.toggle('fa-plus-square');\n    toggleBtn.classList.toggle('fa-minus-square');\n    if (descendants[0].classList.contains('slide-up')) {\n      descWrapper.classList.remove('hidden');\n      this._repaint(children[0]);\n      this._addClass(children, 'slide');\n      this._removeClass(children, 'slide-up');\n      this._one(children[0], 'transitionend', () => {\n        that._removeClass(children, 'slide');\n      });\n    } else {\n      this._addClass(descendants, 'slide slide-up');\n      this._one(descendants[0], 'transitionend', () => {\n        that._removeClass(descendants, 'slide');\n        descendants.forEach(desc => {\n          let ul = that._closest(desc, function (el) {\n            return el.nodeName === 'UL';\n          });\n\n          ul.classList.add('hidden');\n        });\n      });\n\n      descendants.forEach(desc => {\n        let subTBs = Array.from(desc.querySelectorAll('.toggleBtn'));\n\n        that._removeClass(subTBs, 'fa-minus-square');\n        that._addClass(subTBs, 'fa-plus-square');\n      });\n    }\n  }\n  _dispatchClickEvent(event) {\n    let classList = event.target.classList;\n\n    if (classList.contains('topEdge')) {\n      this._clickTopEdge(event);\n    } else if (classList.contains('rightEdge') || classList.contains('leftEdge')) {\n      this._clickHorizontalEdge(event);\n    } else if (classList.contains('bottomEdge')) {\n      this._clickBottomEdge(event);\n    } else if (classList.contains('toggleBtn')) {\n      this._clickToggleButton(event);\n    } else {\n      this._clickNode(event);\n    }\n  }\n  _onDragStart(event) {\n    let nodeDiv = event.target,\n      opts = this.options,\n      isFirefox = /firefox/.test(window.navigator.userAgent.toLowerCase());\n\n    if (isFirefox) {\n      event.dataTransfer.setData('text/html', 'hack for firefox');\n    }\n    // if users enable zoom or direction options\n    if (this.style.transform) {\n      let ghostNode, nodeCover;\n\n      if (!document.querySelector('.ghost-node')) {\n        ghostNode = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        ghostNode.classList.add('ghost-node');\n        nodeCover = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n        ghostNode.appendChild(nodeCover);\n        this.appendChild(ghostNode);\n      } else {\n        ghostNode = this.querySelector(':scope > .ghost-node');\n        nodeCover = ghostNode.children[0];\n      }\n      let transValues = this.style.transform.split(','),\n        scale = Math.abs(window.parseFloat((opts.direction === 't2b' || opts.direction === 'b2t') ?\n          transValues[0].slice(transValues[0].indexOf('(') + 1) : transValues[1]));\n\n      ghostNode.setAttribute('width', nodeDiv.offsetWidth);\n      ghostNode.setAttribute('height', nodeDiv.offsetHeight);\n      nodeCover.setAttribute('x', 5 * scale);\n      nodeCover.setAttribute('y', 5 * scale);\n      nodeCover.setAttribute('width', 120 * scale);\n      nodeCover.setAttribute('height', 40 * scale);\n      nodeCover.setAttribute('rx', 4 * scale);\n      nodeCover.setAttribute('ry', 4 * scale);\n      nodeCover.setAttribute('stroke-width', 1 * scale);\n      let xOffset = event.offsetX * scale,\n        yOffset = event.offsetY * scale;\n\n      if (opts.direction === 'l2r') {\n        xOffset = event.offsetY * scale;\n        yOffset = event.offsetX * scale;\n      } else if (opts.direction === 'r2l') {\n        xOffset = nodeDiv.offsetWidth - event.offsetY * scale;\n        yOffset = event.offsetX * scale;\n      } else if (opts.direction === 'b2t') {\n        xOffset = nodeDiv.offsetWidth - event.offsetX * scale;\n        yOffset = nodeDiv.offsetHeight - event.offsetY * scale;\n      }\n      if (isFirefox) { // hack for old version of Firefox(< 48.0)\n        let ghostNodeWrapper = document.createElement('img');\n\n        ghostNodeWrapper.src = 'data:image/svg+xml;utf8,' + (new XMLSerializer()).serializeToString(ghostNode);\n        event.dataTransfer.setDragImage(ghostNodeWrapper, xOffset, yOffset);\n        nodeCover.setAttribute('fill', 'rgb(255, 255, 255)');\n        nodeCover.setAttribute('stroke', 'rgb(191, 0, 0)');\n      } else {\n        event.dataTransfer.setDragImage(ghostNode, xOffset, yOffset);\n      }\n    }\n    let dragged = event.target,\n      dragZone = this._closest(dragged, (el) => {\n        return el.classList && el.classList.contains('nodes');\n      }).parentNode.children[0].querySelector('.node'),\n      dragHier = Array.from(this._closest(dragged, (el) => {\n        return el.nodeName === 'TABLE';\n      }).querySelectorAll('.node'));\n\n    this.dragged = dragged;\n    Array.from(this.querySelectorAll('.node')).forEach(function (node) {\n      if (!dragHier.includes(node)) {\n        if (opts.dropCriteria) {\n          if (opts.dropCriteria(dragged, dragZone, node)) {\n            node.classList.add('allowedDrop');\n          }\n        } else {\n          node.classList.add('allowedDrop');\n        }\n      }\n    });\n  }\n  _onDragOver(event) {\n    event.preventDefault();\n    let dropZone = event.currentTarget;\n\n    if (!dropZone.classList.contains('allowedDrop')) {\n      event.dataTransfer.dropEffect = 'none';\n    }\n  }\n  _onDragEnd(event) {\n    Array.from(this.querySelectorAll('.allowedDrop')).forEach(function (el) {\n      el.classList.remove('allowedDrop');\n    });\n  }\n  _onDrop(event) {\n    let dropZone = event.currentTarget,\n      dragged = this.dragged,\n      dragZone = this._closest(dragged, function (el) {\n        return el.classList && el.classList.contains('nodes');\n      }).parentNode.children[0].children[0];\n\n    this._removeClass(Array.from(this.querySelectorAll('.allowedDrop')), 'allowedDrop');\n    // firstly, deal with the hierarchy of drop zone\n    if (!dropZone.parentNode.parentNode.nextElementSibling) { // if the drop zone is a leaf node\n      let bottomEdge = document.createElement('i');\n\n      bottomEdge.setAttribute('class', 'edge verticalEdge bottomEdge fa');\n      dropZone.appendChild(bottomEdge);\n      dropZone.parentNode.setAttribute('colspan', 2);\n      let table = this._closest(dropZone, function (el) {\n          return el.nodeName === 'TABLE';\n        }),\n        upperTr = document.createElement('tr'),\n        lowerTr = document.createElement('tr'),\n        nodeTr = document.createElement('tr');\n\n      upperTr.setAttribute('class', 'lines');\n      upperTr.innerHTML = `<td colspan=\"2\"><div class=\"downLine\"></div></td>`;\n      table.appendChild(upperTr);\n      lowerTr.setAttribute('class', 'lines');\n      lowerTr.innerHTML = `<td class=\"rightLine\">&nbsp;</td><td class=\"leftLine\">&nbsp;</td>`;\n      table.appendChild(lowerTr);\n      nodeTr.setAttribute('class', 'nodes');\n      table.appendChild(nodeTr);\n      Array.from(dragged.querySelectorAll('.horizontalEdge')).forEach((hEdge) => {\n        dragged.removeChild(hEdge);\n      });\n      let draggedTd = this._closest(dragged, (el) => el.nodeName === 'TABLE').parentNode;\n\n      nodeTr.appendChild(draggedTd);\n    } else {\n      let dropColspan = window.parseInt(dropZone.parentNode.colSpan) + 2;\n\n      dropZone.parentNode.setAttribute('colspan', dropColspan);\n      dropZone.parentNode.parentNode.nextElementSibling.children[0].setAttribute('colspan', dropColspan);\n      if (!dragged.querySelector('.horizontalEdge')) {\n        let rightEdge = document.createElement('i'),\n          leftEdge = document.createElement('i');\n\n        rightEdge.setAttribute('class', 'edge horizontalEdge rightEdge fa');\n        dragged.appendChild(rightEdge);\n        leftEdge.setAttribute('class', 'edge horizontalEdge leftEdge fa');\n        dragged.appendChild(leftEdge);\n      }\n      let temp = dropZone.parentNode.parentNode.nextElementSibling.nextElementSibling,\n        leftline = document.createElement('td'),\n        rightline = document.createElement('td');\n\n      leftline.setAttribute('class', 'leftLine topLine');\n      leftline.innerHTML = `&nbsp;`;\n      temp.insertBefore(leftline, temp.children[1]);\n      rightline.setAttribute('class', 'rightLine topLine');\n      rightline.innerHTML = `&nbsp;`;\n      temp.insertBefore(rightline, temp.children[2]);\n      temp.nextElementSibling.appendChild(this._closest(dragged, function (el) {\n        return el.nodeName === 'TABLE';\n      }).parentNode);\n\n      let dropSibs = this._siblings(this._closest(dragged, function (el) {\n        return el.nodeName === 'TABLE';\n      }).parentNode).map((el) => el.querySelector('.node'));\n\n      if (dropSibs.length === 1) {\n        let rightEdge = document.createElement('i'),\n          leftEdge = document.createElement('i');\n\n        rightEdge.setAttribute('class', 'edge horizontalEdge rightEdge fa');\n        dropSibs[0].appendChild(rightEdge);\n        leftEdge.setAttribute('class', 'edge horizontalEdge leftEdge fa');\n        dropSibs[0].appendChild(leftEdge);\n      }\n    }\n    // secondly, deal with the hierarchy of dragged node\n    let dragColSpan = window.parseInt(dragZone.colSpan);\n\n    if (dragColSpan > 2) {\n      dragZone.setAttribute('colspan', dragColSpan - 2);\n      dragZone.parentNode.nextElementSibling.children[0].setAttribute('colspan', dragColSpan - 2);\n      let temp = dragZone.parentNode.nextElementSibling.nextElementSibling;\n\n      temp.children[1].remove();\n      temp.children[1].remove();\n\n      let dragSibs = Array.from(dragZone.parentNode.parentNode.children[3].children).map(function (td) {\n        return td.querySelector('.node');\n      });\n\n      if (dragSibs.length === 1) {\n        dragSibs[0].querySelector('.leftEdge').remove();\n        dragSibs[0].querySelector('.rightEdge').remove();\n      }\n    } else {\n      dragZone.removeAttribute('colspan');\n      dragZone.querySelector('.node').removeChild(dragZone.querySelector('.bottomEdge'));\n      Array.from(dragZone.parentNode.parentNode.children).slice(1).forEach((tr) => tr.remove());\n    }\n    let customE = new CustomEvent('nodedropped.orgchart', { 'detail': {\n      'draggedNode': dragged,\n      'dragZone': dragZone.children[0],\n      'dropZone': dropZone\n    }});\n\n    this.dispatchEvent(customE);\n  }\n  // create node\n  _createNode(nodeData, level) {\n    let that = this,\n      opts = this.options;\n\n    return new Promise(function (resolve, reject) {\n      if (nodeData.children) {\n        for (let child of nodeData.children) {\n          child.parentId = nodeData.id;\n        }\n      }\n\n      // construct the content of node\n      let nodeDiv = document.createElement('div');\n\n      delete nodeData.children;\n      nodeDiv.dataset.source = JSON.stringify(nodeData);\n      if (nodeData[opts.nodeId]) {\n        nodeDiv.id = nodeData[opts.nodeId];\n      }\n      let inEdit = that.dataset.inEdit,\n        isHidden;\n\n      if (inEdit) {\n        isHidden = inEdit === 'addChildren' ? ' slide-up' : '';\n      } else {\n        isHidden = level >= opts.depth ? ' slide-up' : '';\n      }\n      nodeDiv.setAttribute('class', 'node ' + (nodeData.className || '') + isHidden);\n      if (opts.draggable) {\n        nodeDiv.setAttribute('draggable', true);\n      }\n      if (nodeData.parentId) {\n        nodeDiv.setAttribute('data-parent', nodeData.parentId);\n      }\n      nodeDiv.innerHTML = `\n        <div class=\"title\">${nodeData[opts.nodeTitle]}</div>\n        ${opts.nodeContent ? `<div class=\"content\">${nodeData[opts.nodeContent]}</div>` : ''}\n      `;\n      // append 4 direction arrows or expand/collapse buttons\n      let flags = nodeData.relationship || '';\n\n      if (opts.verticalDepth && (level + 2) > opts.verticalDepth) {\n        if ((level + 1) >= opts.verticalDepth && Number(flags.substr(2, 1))) {\n          let toggleBtn = document.createElement('i'),\n            icon = level + 1 >= opts.depth ? 'plus' : 'minus';\n\n          toggleBtn.setAttribute('class', 'toggleBtn fa fa-' + icon + '-square');\n          nodeDiv.appendChild(toggleBtn);\n        }\n      } else {\n        if (Number(flags.substr(0, 1))) {\n          let topEdge = document.createElement('i');\n\n          topEdge.setAttribute('class', 'edge verticalEdge topEdge fa');\n          nodeDiv.appendChild(topEdge);\n        }\n        if (Number(flags.substr(1, 1))) {\n          let rightEdge = document.createElement('i'),\n            leftEdge = document.createElement('i');\n\n          rightEdge.setAttribute('class', 'edge horizontalEdge rightEdge fa');\n          nodeDiv.appendChild(rightEdge);\n          leftEdge.setAttribute('class', 'edge horizontalEdge leftEdge fa');\n          nodeDiv.appendChild(leftEdge);\n        }\n        if (Number(flags.substr(2, 1))) {\n          let bottomEdge = document.createElement('i'),\n            symbol = document.createElement('i'),\n            title = nodeDiv.querySelector(':scope > .title');\n\n          bottomEdge.setAttribute('class', 'edge verticalEdge bottomEdge fa');\n          nodeDiv.appendChild(bottomEdge);\n          symbol.setAttribute('class', 'fa ' + opts.parentNodeSymbol + ' symbol');\n          title.insertBefore(symbol, title.children[0]);\n        }\n      }\n\n      nodeDiv.addEventListener('mouseenter', that._hoverNode.bind(that));\n      nodeDiv.addEventListener('mouseleave', that._hoverNode.bind(that));\n      nodeDiv.addEventListener('click', that._dispatchClickEvent.bind(that));\n      if (opts.draggable) {\n        nodeDiv.addEventListener('dragstart', that._onDragStart.bind(that));\n        nodeDiv.addEventListener('dragover', that._onDragOver.bind(that));\n        nodeDiv.addEventListener('dragend', that._onDragEnd.bind(that));\n        nodeDiv.addEventListener('drop', that._onDrop.bind(that));\n      }\n      // allow user to append dom modification after finishing node create of orgchart\n      if (opts.createNode) {\n        opts.createNode(nodeDiv, nodeData);\n      }\n\n      resolve(nodeDiv);\n    });\n  }\n  buildHierarchy(appendTo, nodeData, level, callback) {\n    // Construct the node\n    let that = this,\n      opts = this.options,\n      nodeWrapper,\n      childNodes = nodeData.children,\n      isVerticalNode = opts.verticalDepth && (level + 1) >= opts.verticalDepth;\n\n    if (Object.keys(nodeData).length > 1) { // if nodeData has nested structure\n      nodeWrapper = isVerticalNode ? appendTo : document.createElement('table');\n      if (!isVerticalNode) {\n        appendTo.appendChild(nodeWrapper);\n      }\n      this._createNode(nodeData, level)\n      .then(function (nodeDiv) {\n        if (isVerticalNode) {\n          nodeWrapper.insertBefore(nodeDiv, nodeWrapper.firstChild);\n        } else {\n          let tr = document.createElement('tr');\n\n          tr.innerHTML = `\n            <td ${childNodes ? `colspan=\"${childNodes.length * 2}\"` : ''}>\n            </td>\n          `;\n          tr.children[0].appendChild(nodeDiv);\n          nodeWrapper.insertBefore(tr, nodeWrapper.children[0] ? nodeWrapper.children[0] : null);\n        }\n        if (callback) {\n          callback();\n        }\n      })\n      .catch(function (err) {\n        console.error('Failed to creat node', err);\n      });\n    }\n    // Construct the inferior nodes and connectiong lines\n    if (childNodes) {\n      if (Object.keys(nodeData).length === 1) { // if nodeData is just an array\n        nodeWrapper = appendTo;\n      }\n      let isHidden,\n        isVerticalLayer = opts.verticalDepth && (level + 2) >= opts.verticalDepth,\n        inEdit = that.dataset.inEdit;\n\n      if (inEdit) {\n        isHidden = inEdit === 'addSiblings' ? '' : ' hidden';\n      } else {\n        isHidden = level + 1 >= opts.depth ? ' hidden' : '';\n      }\n\n      // draw the line close to parent node\n      if (!isVerticalLayer) {\n        let tr = document.createElement('tr');\n\n        tr.setAttribute('class', 'lines' + isHidden);\n        tr.innerHTML = `\n          <td colspan=\"${ childNodes.length * 2 }\">\n            <div class=\"downLine\"></div>\n          </td>\n        `;\n        nodeWrapper.appendChild(tr);\n      }\n      // draw the lines close to children nodes\n      let lineLayer = document.createElement('tr');\n\n      lineLayer.setAttribute('class', 'lines' + isHidden);\n      lineLayer.innerHTML = `\n        <td class=\"rightLine\">&nbsp;</td>\n        ${childNodes.slice(1).map(() => `\n          <td class=\"leftLine topLine\">&nbsp;</td>\n          <td class=\"rightLine topLine\">&nbsp;</td>\n          `).join('')}\n        <td class=\"leftLine\">&nbsp;</td>\n      `;\n      let nodeLayer;\n\n      if (isVerticalLayer) {\n        nodeLayer = document.createElement('ul');\n        if (isHidden) {\n          nodeLayer.classList.add(isHidden.trim());\n        }\n        if (level + 2 === opts.verticalDepth) {\n          let tr = document.createElement('tr');\n\n          tr.setAttribute('class', 'verticalNodes' + isHidden);\n          tr.innerHTML = `<td></td>`;\n          tr.firstChild.appendChild(nodeLayer);\n          nodeWrapper.appendChild(tr);\n        } else {\n          nodeWrapper.appendChild(nodeLayer);\n        }\n      } else {\n        nodeLayer = document.createElement('tr');\n        nodeLayer.setAttribute('class', 'nodes' + isHidden);\n        nodeWrapper.appendChild(lineLayer);\n        nodeWrapper.appendChild(nodeLayer);\n      }\n      // recurse through children nodes\n      childNodes.forEach((child) => {\n        let nodeCell;\n\n        if (isVerticalLayer) {\n          nodeCell = document.createElement('li');\n        } else {\n          nodeCell = document.createElement('td');\n          nodeCell.setAttribute('colspan', 2);\n        }\n        nodeLayer.appendChild(nodeCell);\n        that.buildHierarchy(nodeCell, child, level + 1, callback);\n      });\n    }\n  }\n  _clickChart(event) {\n    let closestNode = this._closest(event.target, function (el) {\n      return el.classList && el.classList.contains('node');\n    });\n\n    if (!closestNode && this.querySelector('.node.focused')) {\n      this.querySelector('.node.focused').classList.remove('focused');\n    }\n  }\n  _loopChart(chart) {\n    let subObj = { 'id': chart.querySelector('.node').id };\n\n    if (chart.children[3]) {\n      Array.from(chart.children[3].children).forEach((el) => {\n        if (!subObj.children) { subObj.children = []; }\n        subObj.children.push(this._loopChart(el.firstChild));\n      });\n    }\n    return subObj;\n  }\n  getHierarchy() {\n    if (!this.querySelector('.node').id) {\n      return 'Error: Nodes of orghcart to be exported must have id attribute!';\n    }\n    return this._loopChart(this.querySelector('table'));\n  }\n  _onPanStart(event) {\n    let chart = event.currentTarget;\n\n    if (this._closest(event.target, (el) => el.classList && el.classList.contains('node')) ||\n      (event.touches && event.touches.length > 1)) {\n      chart.dataset.panning = false;\n      return;\n    }\n    chart.style.cursor = 'move';\n    chart.dataset.panning = true;\n\n    let lastX = 0,\n      lastY = 0,\n      lastTf = window.getComputedStyle(chart).transform;\n\n    if (lastTf !== 'none') {\n      let temp = lastTf.split(',');\n\n      if (!lastTf.includes('3d')) {\n        lastX = Number.parseInt(temp[4], 10);\n        lastY = Number.parseInt(temp[5], 10);\n      } else {\n        lastX = Number.parseInt(temp[12], 10);\n        lastY = Number.parseInt(temp[13], 10);\n      }\n    }\n    let startX = 0,\n      startY = 0;\n\n    if (!event.targetTouches) { // pan on desktop\n      startX = event.pageX - lastX;\n      startY = event.pageY - lastY;\n    } else if (event.targetTouches.length === 1) { // pan on mobile device\n      startX = event.targetTouches[0].pageX - lastX;\n      startY = event.targetTouches[0].pageY - lastY;\n    } else if (event.targetTouches.length > 1) {\n      return;\n    }\n    chart.dataset.panStart = JSON.stringify({ 'startX': startX, 'startY': startY });\n    chart.addEventListener('mousemove', this._onPanning.bind(this));\n    chart.addEventListener('touchmove', this._onPanning.bind(this));\n  }\n  _onPanning(event) {\n    let chart = event.currentTarget;\n\n    if (chart.dataset.panning === 'false') {\n      return;\n    }\n    let newX = 0,\n      newY = 0,\n      panStart = JSON.parse(chart.dataset.panStart),\n      startX = panStart.startX,\n      startY = panStart.startY;\n\n    if (!event.targetTouches) { // pand on desktop\n      newX = event.pageX - startX;\n      newY = event.pageY - startY;\n    } else if (event.targetTouches.length === 1) { // pan on mobile device\n      newX = event.targetTouches[0].pageX - startX;\n      newY = event.targetTouches[0].pageY - startY;\n    } else if (event.targetTouches.length > 1) {\n      return;\n    }\n    let lastTf = window.getComputedStyle(chart).transform;\n\n    if (lastTf === 'none') {\n      if (!lastTf.includes('3d')) {\n        chart.style.transform = 'matrix(1, 0, 0, 1, ' + newX + ', ' + newY + ')';\n      } else {\n        chart.style.transform = 'matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, ' + newX + ', ' + newY + ', 0, 1)';\n      }\n    } else {\n      let matrix = lastTf.split(',');\n\n      if (!lastTf.includes('3d')) {\n        matrix[4] = newX;\n        matrix[5] = newY + ')';\n      } else {\n        matrix[12] = newX;\n        matrix[13] = newY;\n      }\n      chart.style.transform = matrix.join(',');\n    }\n  }\n  _onPanEnd(event) {\n    if (this.dataset.panning === 'true') {\n      this.dataset.panning = false;\n      this.style.cursor = 'default';\n      document.body.removeEventListener('mousemove', this._onPanning);\n      document.body.removeEventListener('touchmove', this._onPanning);\n    }\n  }\n  _setChartScale(chart, newScale) {\n    let lastTf = window.getComputedStyle(chart).transform;\n\n    if (lastTf === 'none') {\n      chart.style.transform = 'scale(' + newScale + ',' + newScale + ')';\n    } else {\n      let matrix = lastTf.split(',');\n\n      if (!lastTf.includes('3d')) {\n        matrix[0] = 'matrix(' + newScale;\n        matrix[3] = newScale;\n        chart.style.transform = lastTf + ' scale(' + newScale + ',' + newScale + ')';\n      } else {\n        chart.style.transform = lastTf + ' scale3d(' + newScale + ',' + newScale + ', 1)';\n      }\n    }\n    chart.dataset.scale = newScale;\n  }\n  _onWheeling(event) {\n    event.preventDefault();\n\n    let newScale = event.deltaY > 0 ? 0.8 : 1.2;\n\n    this._setChartScale(this, newScale);\n  }\n  _getPinchDist(event) {\n    return Math.sqrt((event.touches[0].clientX - event.touches[1].clientX) *\n      (event.touches[0].clientX - event.touches[1].clientX) +\n      (event.touches[0].clientY - event.touches[1].clientY) *\n      (event.touches[0].clientY - event.touches[1].clientY));\n  }\n  _onTouchStart(event) {\n    if (event.touches && event.touches.length === 2) {\n      let dist = this._getPinchDist(event);\n\n      this.dataset.pinching = true;\n      this.dataset.pinchDistStart = dist;\n    }\n  }\n  _onTouchMove(event) {\n    if (this.dataset.pinching) {\n      let dist = this._getPinchDist(event);\n\n      this.dataset.pinchDistEnd = dist;\n    }\n  }\n  _onTouchEnd(event) {\n    if (this.dataset.pinching) {\n      this.dataset.pinching = false;\n      let diff = this.dataset.pinchDistEnd - this.dataset.pinchDistStart;\n\n      if (diff > 0) {\n        this._setChartScale(this, 1);\n      } else if (diff < 0) {\n        this._setChartScale(this, -1);\n      }\n    }\n  }\n}\n\nwindow.customElements.define('org-chart', OrgChart);\n\n\n\n// WEBPACK FOOTER //\n// orgchart-webcomponents.js"],"sourceRoot":""}